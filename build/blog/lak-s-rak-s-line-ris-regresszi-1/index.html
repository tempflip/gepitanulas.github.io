<!doctype html>
<html>
<head>

	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

	<meta charset="utf-8">
	
	<title>Hobbi Gépi Tanulás: Lakásárak és lineáris regresszió 1.</title>

	<style>
		div {
		}
	</style>
</head>
<body>
	<div>
		<p>Els&#337; projektemet egy sztenderdnek mondhat&#243; adatszettel csin&#225;lom - a <a href="https://archive.ics.uci.edu/ml/datasets/Housing">Boston Housing Data</a> egy 78-as felm&#233;r&#233;s &#246;tsz&#225;z bostoni lak&#225;s &#225;r&#225;r&#243;l, illetve egy&#233;b tulajdons&#225;gair&#243;l, eg&#233;sz pontosan:</p>
<pre><code> 1. CRIM per capita crime rate by town
 2. ZN proportion of residential land zoned for lots over 25,000 sq.ft.
 3. INDUS proportion of non-retail business acres per town
 4. CHAS Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)
 5. NOX nitric oxides concentration (parts per 10 million)
 6. RM average number of rooms per dwelling
 7. AGE proportion of owner-occupied units built prior to 1940
 8. DIS weighted distances to five Boston employment centres
 9. RAD index of accessibility to radial highways
 10. TAX full-value property-tax rate per $10,000
 11. PTRATIO pupil-teacher ratio by town
 12. B 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
 13. LSTAT % lower status of the population
 14. MEDV Median value of owner-occupied homes in $1000&#39;s
</code></pre><p>Azt felt&#233;telezem, hogy egy adott ingatlan n&#233;h&#225;ny (vagy ak&#225;r az &#246;sszes) tulajdons&#225;g&#225;t ismerve viszonylag j&#243; pontoss&#225;ggal el&#337;rejelezhet&#337; annak az &#225;ra. Az els&#337;re nem t&#369;nik butas&#225;gnak, hiszen egy lak&#225;s &#225;r&#225;t jellemz&#337;en olyan t&#233;nyez&#337;k befoly&#225;solj&#225;k, mint a b&#369;n&#246;z&#233;s m&#233;rt&#233;ke az adott ker&#252;letben, vagy &#233;ppen a v&#225;ros k&#246;zpontj&#225;nak k&#246;zels&#233;ge.</p>
<p><img src="https://tempflip.github.io/img/bl2_1.png" alt="bl2_1"></p>
<p>Egy plotot nyomtatva a b&#369;n&#246;z&#233;s (CRIM, x tengely) &#233;s a lak&#225;s&#225;rak (MEDV, x tengely) &#246;sszef&#252;gg&#233;s&#233;r&#337;l, l&#225;that&#243;, hogy val&#243;ban van <em>valamif&#233;le</em> &#246;sszef&#252;gg&#233;s. Ha ismern&#233;nk azt a f&#252;ggv&#233;nyt, aminek megaddva v&#225;ltoz&#243;nak a b&#369;n&#246;z&#233;s m&#233;rt&#233;k&#233;t megkapn&#225;nk a hozz&#225; tartoz&#243; pontot a fent rajzolt vonalon, akkor meg is lenne a <em>betan&#237;tott g&#233;pi tanul&#225;s modell&#252;nk</em>.</p>
<h3 id="tan-t-s">Tan&#237;t&#225;s</h3>
<p>Ez egy klasszikus [fel&#252;gyelt tanul&#225;si probl&#233;ma] (<a href="https://en.wikipedia.org/wiki/Supervised_learning">https://en.wikipedia.org/wiki/Supervised_learning</a>)</p>
<ul>
<li>Rendelkez&#233;sre &#225;llnak a bemeneti adatok (a b&#369;n&#246;z&#233;s m&#233;rt&#233;ke)</li>
<li>Rendelkez&#233;sre &#225;ll az ahhoz tartoz&#243; eredm&#233;ny (az ingatlan &#225;ra)</li>
<li>Egy f&#252;ggv&#233;nyt szeretn&#233;nk, ami a bemenetet az kimenett&#233; alak&#237;tja</li>
<li>Abban rem&#233;nyked&#252;nk, hogy az &#237;gy k&#233;sz&#237;tett modell a kell&#337;k&#233;ppen &#225;ltal&#225;nos lesz, teh&#225;t alkalmazhat&#243; eddig ismeretlen adatokra is</li>
</ul>
<h3 id="tanul-si-algoritmus">Tanul&#225;si algoritmus</h3>
<p>Tanul&#225;si algoritmusk&#233;nt a line&#225;ris regresszi&#243;t foglyuk haszn&#225;lni. Semmi m&#225;st nem csin&#225;l, mint megtal&#225;lja azt az egyenest, ami a legjobban illeszkedik a tanul&#225;si pontjainkra, majd &#250;j bemeneti &#233;rt&#233;kekre is kisz&#225;molja az egyenes megfelel&#337; pontjait. (Ez nem felt&#233;tlen&#252;l a legjobb v&#225;laszt&#225;s, de egyszer&#369;s&#233;ge miatt most kiv&#225;l&#243;an megfelel).</p>
<h3 id="az-egyenes">Az egyenes</h3>
<p>Egy egyenest &#237;gy lehet le&#237;rni:</p>
<p><code>a + bx</code></p>
<p><code>a</code> a tengelyt&#337;l val&#243; t&#225;vols&#225;g, m&#237;g <code>b</code> az egyenes d&#337;l&#233;se. Amikor egy tanul&#243; algoritmusnak (p&#233;ld&#225;ul a line&#225;ris regresszi&#243;nak) megadjuk a tanul&#243;-pontokat, akkor a sz&#225;m&#237;t&#243;g&#233;p addig tologatja az <code>a</code> &#233;s <code>b</code> pontokat, am&#237;g a hiba m&#233;rt&#233;ke a lehet&#337; legkisebb lesz.</p>
<h3 id="a-hiba">A hiba</h3>
<p>A kapott egyenes term&#233;szetesen nem fog t&#246;k&#233;letesen illeszkedni a pontjainkra (legal&#225;bbis nem val&#243;sz&#237;n&#369;), ez&#233;rt bizonyos hib&#225;val sz&#225;molni kell. A hiba m&#233;rt&#233;k&#233;t t&#246;bbf&#233;lek&#233;ppen ki lehet sz&#225;molni, a legegyszer&#369;bb sz&#225;m&#237;t&#225;s tal&#225;n a <em>Mean Squared Error</em>, (&#225;tlagos n&#233;gyzetes hiba). Itt minden pontn&#225;l kisz&#225;m&#237;tjuk, mennyivel t&#233;r el a f&#252;ggv&#233;ny &#225;ltal tal&#225;lt &#233;rt&#233;kt&#337;l, majd a az elt&#233;r&#233;sek n&#233;gyzet&#233;t &#225;tlagoljuk (a n&#233;gyzet miatt nem kell t&#246;r&#337;dni a plusz-minusz elt&#233;r&#233;sekkel, illetve az extr&#233;m hib&#225;k jobban sz&#225;m&#237;tanak).</p>
<p><img src="https://tempflip.github.io/img/bl2_2.png" alt="bl2_1"></p>
<h1 id="line-ris-regresszi-python-nal">Line&#225;ris regresszi&#243; python-nal</h1>
<p>El&#337;sz&#246;r is sz&#252;ks&#233;g&#252;nk lesz egy modellre. A modellnek k&#233;t dolgot mindenk&#233;ppen tudnia kell: tanulni &#233;s el&#337;rejelezni.</p>
<pre><code>class Linear_Model(Model):
    def __init__(self):
        Model.__init__(self)
        pass

    def train(self, training_x_matrix, training_y_matrix):
        # creating a 1...n space len of the training matrix
        my_space = training_x_matrix.reshape(-1,1)

        # training the model
        regr = linear_model.LinearRegression()
        regr.fit(my_space, training_y_matrix)
        self.model = regr

    def predict(self, x):
        return self.model.predict(x)
</code></pre><p>&#201;s val&#243;j&#225;ban ezzel k&#233;sz is vagyunk, nem is kell m&#225;st tenn&#252;nk mint betan&#237;tani, majd el&#337;rejelezni.</p>
<pre><code>col = &#39;B&#39;
regr = Linear_Model()
regr.train(norm[col], norm[&#39;MEDV&#39;])
predictions[col] = [regr.predict(x) for x in norm[col].values]
print &quot;MSE for {}: {}&quot;.format(col, mean_squared_error(norm[&#39;MEDV&#39;], predictions[col]))
</code></pre><p>A figyelmes olvas&#243; &#233;szreveheti, hogy val&#243;j&#225;ban semmi &quot;&#233;rtelmeset&quot; nem csin&#225;ltunk a fenti sorokban, hiszen azokkal az &#233;rt&#233;kekkel futattuk az el&#337;rejelz&#233;st, amelyekkel tan&#237;tottuk a modellt. &#205;gy azonban az utols&#243; sorban &#246;ssze tudjuk hasonl&#237;tani a val&#243;di &#233;rt&#233;keket az el&#337;rejelz&#233;sekkel, vagyis inform&#225;ci&#243;t kaphatunk a modell &quot;j&#243;s&#225;g&#225;r&#243;l&quot;. A lenti grafikonon a k&#233;k pontok a val&#243;di &#233;rt&#233;kek, m&#237;g a piros az line&#225;ris regresszival k&#233;sz&#237;tett el&#337;rejelz&#233;s <em>ugyanezekre</em> az &#233;rtk&#233;kekre. Az MSE &#233;rt&#233;ke enn&#233;l a vonaln&#225;l 0.0354, ami nem t&#250;l meggy&#337;z&#337;. Ez k&#233;pen &#233;s l&#225;that&#243;, hiszen a vonal illeszked&#233;se nem t&#250;l j&#243;.</p>
<p><img src="https://tempflip.github.io/img/bl2_3.png" alt="bl2_1"></p>
<p>A k&#246;vetkez&#337; postban azzal foglalkozok, hogyan lehet jobb illeszked&#233;st el&#233;rni.</p>

	</div>
</body>
</html>